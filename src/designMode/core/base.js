// 单例模式
// 工厂模式
// 策略模式
// 代理模式
// 中介者模式
// 装饰者模式

// 单例模式
// 保证一个类只有一个实例，并提供一个访问他的全局访问点
// 实现方法为判断实例存在与否，如果存在直接返回，不存在就创建了返回，确保一个类只有一个实例


// 工厂模式
// 工厂角色-负责实现创建所有实例的内部逻辑
// 抽象产品角色-所创建的所有对象的父类，负责描述所有实例所共有的公共接口
// 具体产品角色-是创建目标，所有创建的对象都充当这个角色的某个具体类的实例

// 策略模式
// 就是定义一系列的算法，把他们一一封装起来，并且使他们可以相互替换
// 至少两部分：
// 策略类（可变），策略类封装了具体算法，并负责具体的计算过程
// 环境类（不变），接受客户请求，随后将请求委托给某一个策略类

// 代理模式
// 为对象提供一个代用品或占位符，以便控制对它的访问


// 中介者模式
// 通过一个中介者对象，其它所有相关的对象都通过该中介者对象来通信，而不是相互引用，当其中一个对象发生改变时，只需要通知中介者对象
// 通过中介者模式可以解除对象与对象之间的紧耦合关系

// 装饰者模式
// 在不改变对象自身的基础上，在程序运行期间给对象动态的添加方法
// 通常运用在原有方法维持不变，在原有方法上再挂载其它方法来满足现有需求

